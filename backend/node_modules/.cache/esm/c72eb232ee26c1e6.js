let nodeGeocoder,geo;_ee2‍.x([["distance",()=>distance]]);_ee2‍.w("node-geocoder",[["*",null,function(v){nodeGeocoder=v}]]);_ee2‍.w("geolocation-utils",[["*",null,function(v){geo=v}]]);


let options = {
    provider: 'openstreetmap'
};

let geocoder = nodeGeocoder(options);

       async function distance(adresse_depart_user, adresse_depart_chauffeur) {

    let bool = false;
    const coords_user = await addressToCoordinate(adresse_depart_user);
    const coords_chauffeur = await addressToCoordinate(adresse_depart_chauffeur);

    _ee2‍.g.console.log('Coords user : ' + coords_user.lat, coords_user.lng + ' coords chauffeur : ' + coords_chauffeur.lat, coords_chauffeur.lng);
    
    const isDistanceGood = await distanceBetweenAdress(coords_user, coords_chauffeur);
    
    _ee2‍.g.console.log('Is distance good, function distance : ' + isDistanceGood);
    if (isDistanceGood === true) {
        bool = true;
    }

    return bool;
}

async function addressToCoordinate(adresse) {

    return geocoder.geocode(adresse)
            .then( (res) => {

                return {
                    lat: res[0].latitude,
                    lng: res[0].longitude
                };
            })
            .catch( (error) => {
                _ee2‍.g.console.log('Adress to coordinates error : ' + error);
            });
}     

async function distanceBetweenAdress(coords_user, coords_chauffeur) {

    try {
        
        let distance = geo.headingDistanceTo(coords_user, coords_chauffeur);
        let isDistanceGood = false;

        _ee2‍.g.console.log('Distance distance : ' + distance.distance);
        if (distance.distance <= 1000 ) {
            isDistanceGood = true;
        }

        return isDistanceGood;

    } catch (error) {
        _ee2‍.g.console.log('distance between adress error : ' + error);
    }
}